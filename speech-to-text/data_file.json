{"Video1_2014-04-06T00:00:00": "you guys know how seriously I take solving leetcode problems but people always say that personal projects are more important than solving leetcode problems so I decided to code Elite code cologne it took me three weeks to code this up and honestly it wasn't that hard I'll show you how I did it including the UI the back end and the overall process of adding a new problem let's start with my favorite part the back end ultimately we want user to be able to execute some arbitrary piece of code in other words we're building a code sandbox but we can't just run any code within a browser that would be a security issue and for that reason of browser itself is a Sandbox environment so we need to send the code to our own server but then one of you assholes are going to try to mine Bitcoin on my VM so it's another security issue so we have to execute this code in an isolated environment with the minimum amount of privileges even if I wanted to building something like this would take a lot of time so I followed the number one rule of programming when you see a piece of code you like", "Video1_2014-04-06T00:00:02": "you you ain't get I found judge 0 which is an open source code execution engine they also have an API what you can paper use but I decided to just self-host this so I had to decide which VM would be the best for my use case now obviously running multiple codes emissions especially at the same time is going to be cpu-intensive so I chose a VM with eight cores a python or JavaScript submission would only take about one and a half seconds and only a fraction of that time was actually spent executing code whereas C plus plus code took about two seconds and Jabba took two and a half maybe three seconds even though executing Java code is faster than python or JavaScript I assume most of that time was taken from the jvm start up in like the compilation and all that and I decided to run some benchmarks just to get a ballpark idea of how many requests I would be able to handle I didn't want to waste too much time so my methodology isn't the smartest but basically I had a while loop running a certain amount of submissions at like the exact same time I ran them with", "Video1_2014-04-06T00:00:04": "Python and Java can see the average latency for each request which doesn't really increase until we get to overrate concurrent request submitted at the exact same time and that makes sense cuz rvm has eight cores so theoretically we can have eight submissions running at the same time even with 32 concurrent request the average latency was only 4 seconds now this doesn't tell the whole picture because some of the requests finished in like one and a half seconds where are some of them took up to 8 seconds I repeated this with Java and it was definitely a lot slower in the worst case with 32 concurrent submissions the average request took about 10 seconds the slowest ones took about 19 seconds and this is a very very rough way of estimating the craze for a second but I don't think it's far off if we were able to process 32 request in 20 seconds then I think it's fair to say that our system can handle at least 90 requests per minute and I know that most of my users use Python so I can probably do a lot more than that", "Video1_2014-04-06T00:00:06": "frankly this is going to be more than enough with the amount of traffic that I get now switching over to the UI this was definitely the most annoying part I just hate front end development in general especially because I write pretty much all the CSS on my site and the most interesting part was probably the code editor which once again I just yanked specifically I use the Monica code editor I don't know if that's how you pronounce it but it's the same code editor that vs code uses and I thought if I just need a plug this in it's going to be really easy to use everything's going to work fine and I don't have to worry about it compared to using something like code mirror but that was actually not the case as is typical with front-end development I literally had to set up a custom webpack config which is not something you normally have to do with angular projects and even then I still had issues that just drove me crazy until I finally found a GitHub post which mentioned that you're supposed to downgrade a specific dependency to get it to work this is exactly why I prefer leetcode over", "Video1_2014-04-06T00:00:08": "software development yeah some algorithms definitely are hard as hell but at least you don't have to deal with random BS like this I also thought that I would easily be able to customize the editor theme to get it to look exactly like BS code but even that is actually a lot more complicated than I thought like I'm not able to find an example on the internet of someone doing this and I don't know if that's because I'm just dumb or because this is surprisingly more painful than you would expect somebody knows how to do it please let me know I'll even pay you the rest of the front and features weren't really hard it was just a lot to coat up to be honest like things like changing the font size going into full-screen mode especially like resizing everything that was a huge pain maybe I can explain how I did that in a future video or maybe a course or something like that now for the process of actually adding a new problem so far for the problems I've added the user is asked to design a day to structure which is encapsulated in a class and the process of testing this class involves taking some input.", "Video2_2014-04-06T00:00:00": "get into the class and then comparing the output with the expected output there's a lot of ways you can probably do this you can even use like a unit testing framework probably but I tried to keep things as simple as possible so I actually wrote a driver code file for every single problem and I took the user's code and actually concatenated it to the driver code file so that everything would be in a single file and then I could just take that one file and then send it over to judge zero and then execute the driver could file specifically parses the test input based on that it chooses which method to run of the class in which parameters to pass it and then it takes the output and puts it into a consistent format because I didn't want to define a specific output for every single language for example some languages print are raised differently summer language don't even let you print a raise so that's kind of the responsibility of the driver code now when it comes to sending this to judge zero you can send it in a single submission or you can send a batch submission you would think we would want to do", "Video2_2014-04-06T00:00:02": "batch submission meaning one submission for every single test case programming that is actually a bit more straightforward but the problem that I ran into is that that massively increases the latency and it makes sense why that is because as we talked about earlier when we're executing Java code most of the latency comes from compiling the code and probably starting up the jvm and all that so we have to do that like a dozen times one for each test case it's going to slow our code down a lot but if we only have to do it a single time meaning compiling the code and starting it up and then we can just run every single test case and compare each of those with the expected output that's going to be a lot faster now the one issue with this is at least the way I coded it up each test case output is printed onto a single line so if you as a user have some like log statements in your code as of right now you're not going to be able to see them while you might see them but it's going to mess up the rest of the test cases but I already know", "Video2_2014-04-06T00:00:04": "exactly how to fix that it's just something I'm going to have to do and that actually brings me to another limitation we're right now you as a user can submit your own custom test case the reason for this is for all of the test cases I created I already have the expected output but if you give me a custom test case I don't necessarily know what the expected output is going to be so what I have to do is take my solution code or some solution code run it against your custom test case and run your code against that custom test case and then compare the difference if the output is the same than your code passes be custom test case this is again not like complicated to code up it's just another thing that you have to actually do it even though I said that this whole thing was easier to do than I expected it still is a lot of work does a lot of like features as a lot of edge cases and things to do but now that I've pretty much laid the entire Foundation of this the possibilities are Limitless like I have a dozen ideas of things that I want to start working on now if you're wondering how", "Video2_2014-04-06T00:00:06": "I did all of this so quickly well I had a lot of support from my manager the p.m. the dev team that I work with is really good the CEO likes me the joke is that I'm all of those people cuz I did all this myself but I am getting to the point where I probably do need help the biggest shortcut I probably took and don't tell your Tech lead I told you this but I actually didn't write unit tests at least in my case I think it's a waste of time because I already know like the entire code base I think a lot of times unit test sort of serve as documentation for new Debs and in my case if I update like a certain piece of code I already know all of the other pieces of crowd that might be affected so I can quickly just manually test that everything still works and even when there is a bug which is pretty rare in my case in those cases it's not something a unit test would usually catches usually like a race condition or something like that now if you're thinking wait a minute I thought you just sat in your basement and solve leetcode problems all day but yes that's true I try to upload leetcode problems regularly on my second", "Video2_2014-04-06T00:00:08": "Channel but maybe just maybe there is some correlation with being good at solving leetcode problems especially leetcode hard and being a good developer or at least being able to become a good developer like I see people on Twitter complaining about next js13 oh no the app router it's so complicated guys like I've been doing angular and I'm not saying that like it's a good thing but I'm just saying that maybe being a real Dev isn't as hard as people make it out to be"}